<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
<title>AMOP: amop::MockObject&lt; T, VerifyPolicy &gt; Class Template Reference</title>
<link href="amop.css" rel="stylesheet" type="text/css">
<link href="tabs.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.5.6 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
    </ul>
  </div>
  <div class="tabs">
    <ul>
      <li><a href="annotated.html"><span>Class&nbsp;List</span></a></li>
      <li><a href="functions.html"><span>Class&nbsp;Members</span></a></li>
    </ul>
  </div>
  <div class="navpath"><b>amop</b>::<a class="el" href="classamop_1_1_mock_object.html">MockObject</a>
  </div>
</div>
<div class="contents">
<h1>amop::MockObject&lt; T, VerifyPolicy &gt; Class Template Reference</h1><!-- doxytag: class="amop::MockObject" --><!-- doxytag: inherits="amop::detail::MockObjectBase" -->The main mock object class.  
<a href="#_details">More...</a>
<p>
<code>#include &lt;MockObject.h&gt;</code>
<p>
Inherits amop::detail::MockObjectBase.
<p>

<p>
<a href="classamop_1_1_mock_object-members.html">List of all members.</a><table border="0" cellpadding="0" cellspacing="0">
<tr><td></td></tr>
<tr><td colspan="2"><br><h2>Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classamop_1_1_mock_object.html#dca94c4138ac1746c6b0fb95d3eaa66f">~MockObject</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Destructor.  <a href="#dca94c4138ac1746c6b0fb95d3eaa66f"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class F&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">detail::ReturnMatchBuilder&lt; F, <br>
typename detail::CallPolicy &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classamop_1_1_mock_object.html#a14d1387222a51db73c27c6a8e173f42">call</a> (F method)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Create the <a class="el" href="classamop_1_1_mock_object.html#ss_call">call Mode</a> binding.  <a href="#a14d1387222a51db73c27c6a8e173f42"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">detail::ReturnMatchBuilder<br>
&lt; void(T::*&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classamop_1_1_mock_object.html#dd5d4e75d88160ee7dfcbc62b60a937e">call</a> (const detail::Destructor &amp;))(void *), typename detail::CallPolicy &gt;</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Create the <a class="el" href="classamop_1_1_mock_object.html#ss_call">call Mode</a> binding for destructor.  <a href="#dd5d4e75d88160ee7dfcbc62b60a937e"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class F&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">detail::ReturnMatchBuilder&lt; F, <br>
detail::EveryCallPolicy &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classamop_1_1_mock_object.html#98274a3e75a63d99100ab48b3b4e1588">everyCall</a> (F method)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Create the <a class="el" href="classamop_1_1_mock_object.html#ss_everycall">everyCall Mode</a> binding.  <a href="#98274a3e75a63d99100ab48b3b4e1588"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">detail::ReturnMatchBuilder<br>
&lt; void(T::*&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classamop_1_1_mock_object.html#d1e5e7241820e3fccf47619fe17b4018">everyCall</a> (const detail::Destructor &amp;))(void *), detail::EveryCallPolicy &gt;</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Create the <a class="el" href="classamop_1_1_mock_object.html#ss_everycall">everyCall Mode</a> binding for destructor.  <a href="#d1e5e7241820e3fccf47619fe17b4018"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class F&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">detail::ReturnMatchBuilder&lt; F, <br>
detail::QueryPolicy &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classamop_1_1_mock_object.html#45e34ff648ae99ab4376e53d9891b539">query</a> (F method)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Create the <a class="el" href="classamop_1_1_mock_object.html#ss_query">query Mode</a> binding.  <a href="#45e34ff648ae99ab4376e53d9891b539"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">detail::ReturnMatchBuilder<br>
&lt; void(T::*&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classamop_1_1_mock_object.html#39e89d093e6fa08ab1e1829d397fefb7">query</a> (const detail::Destructor &amp;))(void *), detail::QueryPolicy &gt;</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Create the <a class="el" href="classamop_1_1_mock_object.html#ss_query">query Mode</a> binding for destructor.  <a href="#39e89d093e6fa08ab1e1829d397fefb7"></a><br></td></tr>
</table>
<hr><a name="_details"></a><h2>Detailed Description</h2>
<h3>template&lt;class T, typename VerifyPolicy = AutoVerify&gt;<br>
 class amop::MockObject&lt; T, VerifyPolicy &gt;</h3>

The main mock object class. 
<p>
<a class="el" href="classamop_1_1_mock_object.html" title="The main mock object class.">MockObject</a> is a template class for mocking your interface.<h2><a class="anchor" name="sec_creation">
Initialization</a></h2>
Let's say your want to mock a interface:<p>
<div class="fragment"><pre class="fragment">            <span class="keyword">class </span>Interface
            {
            <span class="keyword">public</span>:                
                
                <span class="keyword">virtual</span> <span class="keywordtype">void</span> foo1() = 0;
                <span class="keyword">virtual</span> <span class="keywordtype">void</span> foo2(<span class="keywordtype">size_t</span> i, <span class="keyword">const</span> std::string&amp; s) = 0;
                <span class="keyword">virtual</span> <span class="keywordtype">size_t</span> foo3() = 0;
                <span class="keyword">virtual</span> <span class="keywordtype">size_t</span> foo4(<span class="keywordtype">size_t</span> i) = 0;
            };  
</pre></div><p>
To create your mock object: <div class="fragment"><pre class="fragment">            MockObject&lt;Interface&gt; mock;
</pre></div><p>
The <code>Interface</code> is what interface you want to mock with and it should be a pure virtual class (No member variables, No non-virtual member functions).<h2><a class="anchor" name="sec_usage">
Usage</a></h2>
After that, you can treat it as a smart pointer of your interface, putting it into your testing functions directly.<p>
<div class="fragment"><pre class="fragment">            <span class="comment">// The functions to test</span>
            <span class="keywordtype">void</span> functionToTest(Interface*);           
            <span class="keywordtype">void</span> functionToTestByRef(Interface&amp;);
            
            <span class="comment">// In your test:          </span>
            functionToTest(mock);
            functionToTestByRef(*mock);
</pre></div><h2><a class="anchor" name="Bindings">
Bindings</a></h2>
<a class="el" href="classamop_1_1_mock_object.html" title="The main mock object class.">MockObject</a> support 3 types of function binding modes: <a class="el" href="classamop_1_1_mock_object.html#ss_call">call Mode</a>, <a class="el" href="classamop_1_1_mock_object.html#ss_everycall">everyCall Mode</a> and <a class="el" href="classamop_1_1_mock_object.html#ss_query">query Mode</a>. But all the usage of this modes are the same:<p>
<div class="fragment"><pre class="fragment">            MockObject&lt;Interface&gt; mock;
            
            mock.everyCall(&amp;Interface::foo2).expect(10, <span class="stringliteral">"String"</span>);
            
            mock.call(&amp;Interface::foo3).returning(20);                       
            
            <span class="keywordtype">size_t</span> numberOfCalls = mock.query(&amp;Interface::foo4).count();            
</pre></div><p>
After you binded your functions to the mock object, you can peform verify the arguments, query the number of times the function called and redirect it to your own function etc., according the modes you choosed.<p>
And you can mix these modes together by calling it twice:<p>
<div class="fragment"><pre class="fragment">            <span class="comment">// The Interface::foo4 will return 10 every times</span>
            mock.everyCall(&amp;Interface::foo4).returning(10);
            
            <span class="comment">// The &amp;Interface::foo4 expect 10, and then 20</span>
            mock.call(&amp;Interface::foo4)
                .expect(10)
                .expect(20);          
</pre></div><h3><a class="anchor" name="ss_call">
call Mode</a></h3>
In this mode, your can verify the arguments, setting the return values of your function. <b>The number of calls must match exactly, each call has distinct arguments that it shall verify against, and distinct return values it shall mock. </b> When the expectation is not corrected, an exception will be thrown:<p>
<div class="fragment"><pre class="fragment">            mock.call(&amp;Interface::foo4)
                .expect(10).Return(1)
                .expect(20).Return(2);          
            
            <span class="comment">// We use UnitTest++ here, but you can use any unit-test library with amop.</span>
            CHECK(1, mock-&gt;foo4(10));
            CHECK(2, mock-&gt;foo4(20));

            CHECK_THROW(mock-&gt;foo4(30), CallCountException);            
</pre></div><p>
The <a class="el" href="classamop_1_1_mock_object.html#a14d1387222a51db73c27c6a8e173f42" title="Create the call Mode binding.">MockObject::call</a> method will bind your given method to call mode, and it will return an object, which you can call its method to setting the behaviors of given function when it is mocked. Please reference <a class="el" href="classamop_1_1detail_1_1_return_match_builder_3_01_f_00_01detail_1_1_call_policy_01_4.html" title="The builder object for call mode.">detail::ReturnMatchBuilder&lt;F, detail::CallPolicy&gt;</a> for its usage.<p>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="classamop_1_1_mock_object.html#a14d1387222a51db73c27c6a8e173f42" title="Create the call Mode binding.">MockObject::call</a> <p>
<a class="el" href="classamop_1_1detail_1_1_return_match_builder_3_01_f_00_01detail_1_1_call_policy_01_4.html" title="The builder object for call mode.">detail::ReturnMatchBuilder&lt;F, detail::CallPolicy&gt;</a></dd></dl>
<h3><a class="anchor" name="ss_everycall">
everyCall Mode</a></h3>
The everyCall mode is very similar to <a class="el" href="classamop_1_1_mock_object.html#ss_call">call Mode</a> , except verify arguments an infinite number of times, and shall not care about number of calls:<p>
<div class="fragment"><pre class="fragment">            mock.everyCall(&amp;Interface::foo4)
                .expect(10).Return(1)

            CHECK(1, mock-&gt;foo4(10);
            CHECK(1, mock-&gt;foo4(10);
            CHECK(1, mock-&gt;foo4(10);
            CHECK(1, mock-&gt;foo4(10);
</pre></div><p>
The <a class="el" href="classamop_1_1_mock_object.html#98274a3e75a63d99100ab48b3b4e1588" title="Create the everyCall Mode binding.">MockObject::everyCall</a> method will return an object in everyCall mode, which you can setting the behaviors like <a class="el" href="classamop_1_1_mock_object.html#a14d1387222a51db73c27c6a8e173f42" title="Create the call Mode binding.">MockObject::call</a> return object does. Please reference <a class="el" href="classamop_1_1detail_1_1_return_match_builder_3_01_f_00_01detail_1_1_every_call_policy_01_4.html" title="The builder object for EveryCall mode.">detail::ReturnMatchBuilder&lt;F, detail::EveryCallPolicy&gt;</a> for its usage.<p>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="classamop_1_1_mock_object.html#98274a3e75a63d99100ab48b3b4e1588" title="Create the everyCall Mode binding.">MockObject::everyCall</a> <p>
<a class="el" href="classamop_1_1detail_1_1_return_match_builder_3_01_f_00_01detail_1_1_every_call_policy_01_4.html" title="The builder object for EveryCall mode.">detail::ReturnMatchBuilder&lt;F, detail::EveryCallPolicy&gt;</a></dd></dl>
<h3><a class="anchor" name="ss_query">
query Mode</a></h3>
The query Mode is used for getting the function's propeties for mocking (Like the number of calls):<p>
<div class="fragment"><pre class="fragment">            mock.everyCall(&amp;Inteface::foo4).Return(1)

            mock-&gt;foo4(10);
            mock-&gt;foo4(10);
            mock-&gt;foo4(10);
            mock-&gt;foo4(10);
            mock-&gt;foo4(10);

            CHECK(5, mock.query(&amp;Interface::foo4).Count())
</pre></div><p>
Please reference <a class="el" href="classamop_1_1detail_1_1_return_match_builder_3_01_f_00_01detail_1_1_query_policy_01_4.html" title="The builder object for Query mode.">detail::ReturnMatchBuilder&lt;F, detail::QueryPolicy&gt;</a> for its usage.<p>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="classamop_1_1_mock_object.html#45e34ff648ae99ab4376e53d9891b539" title="Create the query Mode binding.">MockObject::query</a> <p>
<a class="el" href="classamop_1_1detail_1_1_return_match_builder_3_01_f_00_01detail_1_1_query_policy_01_4.html" title="The builder object for Query mode.">detail::ReturnMatchBuilder&lt;F, detail::QueryPolicy&gt;</a></dd></dl>
<h3><a class="anchor" name="ss_destructor">
Binding to destructor</a></h3>
In some case, your will want to mock the destructor of a interface, your can use the trait function destructor():<p>
<div class="fragment"><pre class="fragment">            mock.call(destructor());
</pre></div><p>
<dl class="remark" compact><dt><b>Remarks:</b></dt><dd>In fact, it is not binding to your constructor directly, but it is binding to the delete operator of your interface. However, because it is a pure virutal class, there are only 2 way to call the destructor, one is delete it by using the delete operator, another one is call it directly ( mock-&gt;~YourInterface() ). Normally latter method is rarely happened. </dd></dl>
<hr><h2>Constructor &amp; Destructor Documentation</h2>
<a class="anchor" name="dca94c4138ac1746c6b0fb95d3eaa66f"></a><!-- doxytag: member="amop::MockObject::~MockObject" ref="dca94c4138ac1746c6b0fb95d3eaa66f" args="()" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, typename VerifyPolicy = AutoVerify&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classamop_1_1_mock_object.html">amop::MockObject</a>&lt; T, VerifyPolicy &gt;::~<a class="el" href="classamop_1_1_mock_object.html">MockObject</a>           </td>
          <td>(</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Destructor. 
<p>
The destructor of <a class="el" href="classamop_1_1_mock_object.html" title="The main mock object class.">MockObject</a>, 
</div>
</div><p>
<hr><h2>Member Function Documentation</h2>
<a class="anchor" name="a14d1387222a51db73c27c6a8e173f42"></a><!-- doxytag: member="amop::MockObject::call" ref="a14d1387222a51db73c27c6a8e173f42" args="(F method)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, typename VerifyPolicy = AutoVerify&gt; </div>
<div class="memtemplate">
template&lt;class F&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">detail::ReturnMatchBuilder&lt;F, typename detail::CallPolicy&gt; <a class="el" href="classamop_1_1_mock_object.html">amop::MockObject</a>&lt; T, VerifyPolicy &gt;::call           </td>
          <td>(</td>
          <td class="paramtype">F&nbsp;</td>
          <td class="paramname"> <em>method</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Create the <a class="el" href="classamop_1_1_mock_object.html#ss_call">call Mode</a> binding. 
<p>
This function create the <a class="el" href="classamop_1_1_mock_object.html#ss_call">call Mode</a> binding. The <a class="el" href="classamop_1_1_mock_object.html#ss_call">call Mode</a> is used for verify and setting arguments for each calls, which the number of calls must match exactly.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>method</em>&nbsp;</td><td>The method to be binding with</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>The builder object for setting the behavior the given method.</dd></dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="classamop_1_1_mock_object.html#ss_call">call Mode</a>, <a class="el" href="classamop_1_1detail_1_1_return_match_builder_3_01_f_00_01detail_1_1_call_policy_01_4.html" title="The builder object for call mode.">detail::ReturnMatchBuilder&lt;F, detail::CallPolicy&gt;</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="dd5d4e75d88160ee7dfcbc62b60a937e"></a><!-- doxytag: member="amop::MockObject::call" ref="dd5d4e75d88160ee7dfcbc62b60a937e" args="(const detail::Destructor &amp;))(void *), typename detail::CallPolicy &gt;" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, typename VerifyPolicy = AutoVerify&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">detail::ReturnMatchBuilder&lt;void (T::* <a class="el" href="classamop_1_1_mock_object.html">amop::MockObject</a>&lt; T, VerifyPolicy &gt;::call           </td>
          <td>(</td>
          <td class="paramtype">const detail::Destructor &amp;&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Create the <a class="el" href="classamop_1_1_mock_object.html#ss_call">call Mode</a> binding for destructor. 
<p>
This function create the <a class="el" href="classamop_1_1_mock_object.html#ss_call">call Mode</a> binding for destructor. The <a class="el" href="classamop_1_1_mock_object.html#ss_call">call Mode</a> is used for verify and setting arguments for each calls, which the number of calls must match exactly. To binding a function to destructor, using the destructor() trait function.<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>The builder object for setting the behavior the given method.</dd></dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="classamop_1_1_mock_object.html#ss_call">call Mode</a>, <a class="el" href="classamop_1_1_mock_object.html#ss_destructor">Binding to destructor</a>, <a class="el" href="classamop_1_1detail_1_1_return_match_builder_3_01_f_00_01detail_1_1_call_policy_01_4.html" title="The builder object for call mode.">detail::ReturnMatchBuilder&lt;F, detail::CallPolicy&gt;</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="98274a3e75a63d99100ab48b3b4e1588"></a><!-- doxytag: member="amop::MockObject::everyCall" ref="98274a3e75a63d99100ab48b3b4e1588" args="(F method)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, typename VerifyPolicy = AutoVerify&gt; </div>
<div class="memtemplate">
template&lt;class F&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">detail::ReturnMatchBuilder&lt;F, detail::EveryCallPolicy&gt; <a class="el" href="classamop_1_1_mock_object.html">amop::MockObject</a>&lt; T, VerifyPolicy &gt;::everyCall           </td>
          <td>(</td>
          <td class="paramtype">F&nbsp;</td>
          <td class="paramname"> <em>method</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Create the <a class="el" href="classamop_1_1_mock_object.html#ss_everycall">everyCall Mode</a> binding. 
<p>
This function create the ss_everycall binding. The ss_everycall is used for verify arguments an infinite number of times, and shall not care about number of calls.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>method</em>&nbsp;</td><td>The method to be binding with</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>The builder object for setting the behavior the given method.</dd></dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="classamop_1_1_mock_object.html#ss_everycall">everyCall Mode</a>, <a class="el" href="classamop_1_1detail_1_1_return_match_builder_3_01_f_00_01detail_1_1_every_call_policy_01_4.html" title="The builder object for EveryCall mode.">detail::ReturnMatchBuilder&lt;F, detail::EveryCallPolicy&gt;</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="d1e5e7241820e3fccf47619fe17b4018"></a><!-- doxytag: member="amop::MockObject::everyCall" ref="d1e5e7241820e3fccf47619fe17b4018" args="(const detail::Destructor &amp;))(void *), detail::EveryCallPolicy &gt;" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, typename VerifyPolicy = AutoVerify&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">detail::ReturnMatchBuilder&lt;void (T::* <a class="el" href="classamop_1_1_mock_object.html">amop::MockObject</a>&lt; T, VerifyPolicy &gt;::everyCall           </td>
          <td>(</td>
          <td class="paramtype">const detail::Destructor &amp;&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Create the <a class="el" href="classamop_1_1_mock_object.html#ss_everycall">everyCall Mode</a> binding for destructor. 
<p>
This function create the ss_everycall binding for destructor. The ss_everycall is used for verify and setting arguments for each calls, which the number of calls must match exactly. To binding a function to destructor, using the destructor() trait function.<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>The builder object for setting the behavior the given method.</dd></dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="classamop_1_1_mock_object.html#ss_everycall">everyCall Mode</a>, <a class="el" href="classamop_1_1_mock_object.html#ss_destructor">Binding to destructor</a>, <a class="el" href="classamop_1_1detail_1_1_return_match_builder_3_01_f_00_01detail_1_1_every_call_policy_01_4.html" title="The builder object for EveryCall mode.">detail::ReturnMatchBuilder&lt;F, detail::EveryCallPolicy&gt;</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="45e34ff648ae99ab4376e53d9891b539"></a><!-- doxytag: member="amop::MockObject::query" ref="45e34ff648ae99ab4376e53d9891b539" args="(F method)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, typename VerifyPolicy = AutoVerify&gt; </div>
<div class="memtemplate">
template&lt;class F&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">detail::ReturnMatchBuilder&lt;F, detail::QueryPolicy&gt; <a class="el" href="classamop_1_1_mock_object.html">amop::MockObject</a>&lt; T, VerifyPolicy &gt;::query           </td>
          <td>(</td>
          <td class="paramtype">F&nbsp;</td>
          <td class="paramname"> <em>method</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Create the <a class="el" href="classamop_1_1_mock_object.html#ss_query">query Mode</a> binding. 
<p>
This function create the <a class="el" href="classamop_1_1_mock_object.html#ss_query">query Mode</a> binding. The <a class="el" href="classamop_1_1_mock_object.html#ss_query">query Mode</a> is used for getting the property of mocking function (Like the number calls)<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>method</em>&nbsp;</td><td>The method to be binding with</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>The builder object for getting the behavior the given method.</dd></dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="classamop_1_1_mock_object.html#ss_query">query Mode</a>, <a class="el" href="classamop_1_1detail_1_1_return_match_builder_3_01_f_00_01detail_1_1_query_policy_01_4.html" title="The builder object for Query mode.">detail::ReturnMatchBuilder&lt;F, detail::QueryPolicy&gt;</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="39e89d093e6fa08ab1e1829d397fefb7"></a><!-- doxytag: member="amop::MockObject::query" ref="39e89d093e6fa08ab1e1829d397fefb7" args="(const detail::Destructor &amp;))(void *), detail::QueryPolicy &gt;" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, typename VerifyPolicy = AutoVerify&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">detail::ReturnMatchBuilder&lt;void (T::* <a class="el" href="classamop_1_1_mock_object.html">amop::MockObject</a>&lt; T, VerifyPolicy &gt;::query           </td>
          <td>(</td>
          <td class="paramtype">const detail::Destructor &amp;&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Create the <a class="el" href="classamop_1_1_mock_object.html#ss_query">query Mode</a> binding for destructor. 
<p>
This function create the <a class="el" href="classamop_1_1_mock_object.html#ss_query">query Mode</a> binding for destructor. The <a class="el" href="classamop_1_1_mock_object.html#ss_query">query Mode</a> is used for getting the property of mocking function (Like the number calls) To binding a function to destructor, using the destructor() trait function.<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>The builder object for getting the behavior the given method.</dd></dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="classamop_1_1_mock_object.html#ss_query">query Mode</a>, <a class="el" href="classamop_1_1detail_1_1_return_match_builder_3_01_f_00_01detail_1_1_query_policy_01_4.html" title="The builder object for Query mode.">detail::ReturnMatchBuilder&lt;F, detail::QueryPolicy&gt;</a> </dd></dl>

</div>
</div><p>
<hr>The documentation for this class was generated from the following file:<ul>
<li>C:/Sandbox/amop/amop_project/trunk/amop/Include/MockObject.h</ul>
</div>
<hr size="1"><address style="text-align: right;"><small>
Generated on Thu Nov 27 02:35:21 2008 for AMOP by&nbsp;<a href="http://www.doxygen.org/index.html"><img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.5.6</small></address>
</body>
</html>
